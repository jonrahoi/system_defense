/*
 * Implementation of a component object (either a client or processor)
 *
 * Each component has an idea generated by the interface and passed down to
 * the logic level. They also are created with the specs defined in the
 * 'config/components.js' file. An individual component object keeps track
 * of all of its queued and processing requests. It also has a "forwarding
 * function" which defines how requests should be emitted from the component.
 * 
 * Has no knowledge of position, image display, etc. Only knows the number
 * of input/output connections and relevant number of requests.
 */
export default function LogicComponent(id, name, specs) {
    this.id = id;
    this.name = name;

    this.connectedInputs = 0;
    this.connectedOutputs = 0;
    this.numProcessing = 0;
    this.numProcessed = 0;

    this.requestQueue = [];
    this.forwardFunc = undefined; // not yet implemented
    this.build(specs);

    /* HAS THESE PROPERTIES AS WELL. ACQUIRED BY `this.build(specs)`:
     * type
     * cost
     * maxInputs
     * maxOutputs
     * requestCapacity
     * (throughput) - if processor
     * description
     */
}

// may be able to integrate into construtor...
LogicComponent.prototype.build = function(specs) {
    Object.assign(this, specs);
};

/** Game IO control **/
LogicComponent.prototype.addInput = function() {
    if (this.hasAvailableInput()) {
        this.connectedInputs++;
        return true;
    }
    return false;
};
LogicComponent.prototype.addOutput = function() {
    if (this.hasAvailableOutput()) {
        this.connectedOutputs++;
        return true;
    }
    return false;
};

LogicComponent.prototype.removeInput = function() {
    this.connectedInputs = Math.max(this.connectedInputs - 1, 0);
};
LogicComponent.prototype.removeOutput = function() {
    this.connectedOutputs = Math.max(this.connectedOutputs - 1, 0);
};

LogicComponent.prototype.hasAvailableInput = function() {
    return this.connectedInputs < this.level[1].maxInputs;
};
LogicComponent.prototype.hasAvailableOutput = function() {
    return this.connectedOutputs < this.level[1].maxOutputs;
};

/** Request management **/
LogicComponent.prototype.enqueue = function (request) {
    this.requestQueue.push(request);
    if (this.requestQueue.length < this.requestCapacity) {
        this.numProcessing++;
        return true;
    }
    return false;
}
LogicComponent.prototype.dequeue = function() {
    if (this.numProcessing > 0) {
        this.numProcessing--;
        this.numProcessed++;
    }
    return this.requestQueue.shift();
}
LogicComponent.prototype.getAvailability = function() {
    return this.requestCapacity - this.containedRequests;
};
LogicComponent.prototype.isAvailable = function() {
    return this.numProcessing < this.requestCapacity;
};
// Need functions for processing each request. Maybe needs a processTimestep()?

/** Component control **/
LogicComponent.prototype.softReset = function() {
    this.numProcessed = 0;
    this.numProcessing = 0;
    this.requestQueue = [];
};
LogicComponent.prototype.hardReset = function() {
    this.softReset();
    this.connectedInputs = 0;
    this.connectedOutputs = 0;
};
