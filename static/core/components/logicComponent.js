import { Connection } from "./Connection.js";
/*
 * Implementation of a component object (either a client or processor)
 *
 * Each component has an idea generated by the interface and passed down to
 * the logic level. They also are created with the specs defined in the
 * 'config/components.js' file. An individual component object keeps track
 * of all of its queued and processing requests. It also has a "forwarding
 * function" which defines how requests should be emitted from the component.
 * 
 * Has no knowledge of position, image display, etc. Only knows the number
 * of input/output connections and relevant number of requests.
 */
export default function LogicComponent(id, name, specs, x=0, y=0) {
    this.id = id;
    this.name = name;

    this.x = x;
    this.y = y;

    this.connectedInputs = 0;
    this.connectedOutputs = 0;
    this.numProcessing = 0;
    this.numProcessed = 0;

    this.maxInputs = 999;
    this.maxOutputs = 999;

    this.connections = [];
    this.requestQueue = [];
    this.forwardFunc = undefined; // not yet implemented
    this.build(specs);
}

// may be able to integrate into construtor...
LogicComponent.prototype.build = function(specs) {
    Object.assign(this, specs);
};

/** Game IO control **/
LogicComponent.prototype.addInput = function() {
    if (this.hasAvailableInput()) {
        this.connectedInputs++;
        return true;
    }
    return false;
};
LogicComponent.prototype.addOutput = function() {
    if (this.hasAvailableOutput()) {
        this.connectedOutputs++;
        return true;
    }
    return false;
};

LogicComponent.prototype.removeInput = function() {
    this.connectedInputs = Math.max(this.connectedInputs - 1, 0);
};
LogicComponent.prototype.removeOutput = function() {
    this.connectedOutputs = Math.max(this.connectedOutputs - 1, 0);
};

LogicComponent.prototype.hasAvailableInput = function() {
    return this.connectedInputs < this.maxInputs;
};
LogicComponent.prototype.hasAvailableOutput = function() {
    return this.connectedOutputs < this.maxOutputs;
};

/** Request management **/
LogicComponent.prototype.enqueue = function (request) {
    this.requestQueue.push(request);
    if (this.requestQueue.length < this.requestCapacity) {
        this.numProcessing++;
        return true;
    }
    return false;
}
LogicComponent.prototype.dequeue = function() {
    if (this.numProcessing > 0) {
        this.numProcessing--;
        this.numProcessed++;
    }
    return this.requestQueue.shift();
}
LogicComponent.prototype.getAvailability = function() {
    return this.requestCapacity - this.containedRequests;
};
LogicComponent.prototype.isAvailable = function() {
    return this.numProcessing < this.requestCapacity;
};
// Need functions for processing each request. Maybe needs a processTimestep()?

/** Component control **/
LogicComponent.prototype.softReset = function() {
    this.numProcessed = 0;
    this.numProcessing = 0;
    this.requestQueue = [];
};
LogicComponent.prototype.hardReset = function() {
    this.softReset();
    this.connectedInputs = 0;
    this.connectedOutputs = 0;
};

LogicComponent.prototype.setX = function(x) {
  this.x = Math.max(pos,0)
};

LogicComponent.prototype.setY = function(y) {
  this.y = Math.max(pos,0)
};
LogicComponent.prototype.getX = function() {
  return this.x
};
LogicComponent.prototype.getY = function() {
  return this.y
};
LogicComponent.prototype.getID = function() {
  return this.id
};
// get all the connections base on this node
LogicComponent.prototype.getPrevNeighbors = function() {
  let nodes = [];
  this.connections.forEach(function(connection) {
      if (connection.src.id !== this.id) {
          nodes.push(connection.src);
      }
  }.bind(this));
  return nodes;
};
// get all the connection in this node 
LogicComponent.prototype.getNextNeighbors = function() {
  let nodes = [];
  this.connections.forEach(function(connection) {
      if (connection.des.id !== this.id) {
          nodes.push(connection.des);
      }
  }.bind(this));
  return nodes;
};

/**
 * 
 * @param {LogicComponent} target 
 * @returns 
 */
LogicComponent.prototype.getOutputConnection = function(target) {
  return this.connections.find(c => {
    return c.target.equals(target);
  });
};
// checking if it is the same node
LogicComponent.prototype.equals = function(other) {
  if (!(other instanceof LogicComponent)) {
    return false;
  }
  return other.id === this.id;
};
// add and serach connection
LogicComponent.prototype.addConnection = function(connection) {
  if (!(connection instanceof Connection)){
    console.debug("addConnection's input is not Connection")
    return false
  }
  this.connections.push(connection);
  return true
};
